{"message":"this file contains an unclosed delimiter","code":null,"level":"error","spans":[{"file_name":"src/eval.rs","byte_start":16584,"byte_end":16585,"line_start":461,"line_end":461,"column_start":199,"column_end":200,"is_primary":false,"text":[{"text":"fn scalar_function<S: AsRef<str>>(name: S, larg: Option<AST>, rarg: Option<AST>, s: &String, loc: Location, env: &mut HashMap<String, AST>, fail_extern: bool, redr: Redirect) -> Result<AST, String> {","highlight_start":199,"highlight_end":200}],"label":"unclosed delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eval.rs","byte_start":20950,"byte_end":20951,"line_start":546,"line_end":546,"column_start":50,"column_end":51,"is_primary":false,"text":[{"text":"          let mut vs = s.split(\"\\n\").map(|e| AST { variant: ","highlight_start":50,"highlight_end":51}],"label":"this delimiter might not be properly closed...","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eval.rs","byte_start":21270,"byte_end":21271,"line_start":550,"line_end":550,"column_start":32,"column_end":33,"is_primary":false,"text":[{"text":"              }, location: loc }).collect::<Vec<AST>>();","highlight_start":32,"highlight_end":33}],"label":"...as it matches this but it has different indentation","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eval.rs","byte_start":54561,"byte_end":54561,"line_start":1371,"line_end":1371,"column_start":2,"column_end":2,"is_primary":true,"text":[{"text":"}","highlight_start":2,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: this file contains an unclosed delimiter\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/eval.rs:1371:2\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mfn scalar_function<S: AsRef<str>>(name: S, larg: Option<AST>, rarg: Option<AST>, s: &String, loc: Location, env: &mut HashMap<String, AST>, fail_extern: bool, redr: Redirect) -> Result<AST, String> {\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                                                                                                                                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12munclosed delimiter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m546\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m          let mut vs = s.split(\"\\n\").map(|e| AST { variant: \u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mthis delimiter might not be properly closed...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m550\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m              }, location: loc }).collect::<Vec<AST>>();\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...as it matches this but it has different indentation\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1371\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\n\n"}
{"message":"expected one of `,`, `.`, `?`, `}`, or an operator, found `{`","code":null,"level":"error","spans":[{"file_name":"src/eval.rs","byte_start":16584,"byte_end":16585,"line_start":461,"line_end":461,"column_start":199,"column_end":200,"is_primary":true,"text":[{"text":"fn scalar_function<S: AsRef<str>>(name: S, larg: Option<AST>, rarg: Option<AST>, s: &String, loc: Location, env: &mut HashMap<String, AST>, fail_extern: bool, redr: Redirect) -> Result<AST, String> {","highlight_start":199,"highlight_end":200}],"label":"unclosed delimiter","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eval.rs","byte_start":21414,"byte_end":21415,"line_start":552,"line_end":552,"column_start":118,"column_end":119,"is_primary":true,"text":[{"text":"          if vs.len() > 0 && match &vs[vs.len() - 1].variant { ASTVal::String(s) if s.len() == 0 => true, _ => false {","highlight_start":118,"highlight_end":119}],"label":"expected one of `,`, `.`, `?`, `}`, or an operator","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eval.rs","byte_start":21405,"byte_end":21407,"line_start":552,"line_end":552,"column_start":109,"column_end":111,"is_primary":false,"text":[{"text":"          if vs.len() > 0 && match &vs[vs.len() - 1].variant { ASTVal::String(s) if s.len() == 0 => true, _ => false {","highlight_start":109,"highlight_end":111}],"label":"while parsing the `match` arm starting here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`}` may belong here","code":null,"level":"help","spans":[{"file_name":"src/eval.rs","byte_start":21413,"byte_end":21413,"line_start":552,"line_end":552,"column_start":117,"column_end":117,"is_primary":true,"text":[{"text":"          if vs.len() > 0 && match &vs[vs.len() - 1].variant { ASTVal::String(s) if s.len() == 0 => true, _ => false {","highlight_start":117,"highlight_end":117}],"label":null,"suggested_replacement":"}","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected one of `,`, `.`, `?`, `}`, or an operator, found `{`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/eval.rs:461:199\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m461\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m: Location, env: &mut HashMap<String, AST>, fail_extern: bool, redr: Redirect) -> Result<AST, String> {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9munclosed delimiter\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m552\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m => true, _ => false {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected one of `,`, `.`, `?`, `}`, or an operator\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: `}` may belong here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m               \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mwhile parsing the `match` arm starting here\u001b[0m\n\n"}
{"message":"expected `{`, found `,`","code":null,"level":"error","spans":[{"file_name":"src/eval.rs","byte_start":21602,"byte_end":21603,"line_start":557,"line_end":557,"column_start":10,"column_end":11,"is_primary":true,"text":[{"text":"        },","highlight_start":10,"highlight_end":11}],"label":"expected `{`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the `if` expression is missing a block after this condition","code":null,"level":"note","spans":[{"file_name":"src/eval.rs","byte_start":21310,"byte_end":21602,"line_start":552,"line_end":557,"column_start":14,"column_end":10,"is_primary":true,"text":[{"text":"          if vs.len() > 0 && match &vs[vs.len() - 1].variant { ASTVal::String(s) if s.len() == 0 => true, _ => false {","highlight_start":14,"highlight_end":119},{"text":"            vs.pop();","highlight_start":1,"highlight_end":22},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"          ","highlight_start":1,"highlight_end":11},{"text":"          Ok(AST { variant: match vs { vs if vs.len() != 1 => ASTVal::Array(vs), mut vs => vs.remove(0).variant }, location: loc })","highlight_start":1,"highlight_end":132},{"text":"        },","highlight_start":1,"highlight_end":10}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected `{`, found `,`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/eval.rs:557:10\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m557\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        },\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `{`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;10mnote\u001b[0m\u001b[0m: the `if` expression is missing a block after this condition\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/eval.rs:552:14\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m552\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m          if vs.len() > 0 && match &vs[vs.len() - 1].variant { ASTVal::String(s) if s.len() == 0 => true, _ => false {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m______________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m553\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            vs.pop();\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m554\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m          }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m555\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m          \u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m556\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m          Ok(AST { variant: match vs { vs if vs.len() != 1 => ASTVal::Array(vs), mut vs => vs.remove(0).variant }, location: loc })\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m557\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        },\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;10m|_________^\u001b[0m\n\n"}
{"message":"expected expression, found `,`","code":null,"level":"error","spans":[{"file_name":"src/eval.rs","byte_start":22160,"byte_end":22161,"line_start":564,"line_end":564,"column_start":6,"column_end":7,"is_primary":true,"text":[{"text":"    },","highlight_start":6,"highlight_end":7}],"label":"expected expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: expected expression, found `,`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/eval.rs:564:6\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m564\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    },\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m     \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected expression\u001b[0m\n\n"}
{"message":"cannot find function `resolve` in module `eval`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/terminal.rs","byte_start":1128,"byte_end":1135,"line_start":46,"line_end":46,"column_start":62,"column_end":69,"is_primary":true,"text":[{"text":"  let resolved = commands.and_then(|cmds| cmds.map(|c| eval::resolve(c, environment, &command)).map_or(Ok(None), |v| v.map(Some)));","highlight_start":62,"highlight_end":69}],"label":"not found in `eval`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find function `resolve` in module `eval`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/terminal.rs:46:62\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m46\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  let resolved = commands.and_then(|cmds| cmds.map(|c| eval::resolve(c, environment, &command)).map_or(Ok(None), |v| v.map(Some)));\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `eval`\u001b[0m\n\n"}
{"message":"cannot find function `eval_commands` in module `eval`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"src/terminal.rs","byte_start":1251,"byte_end":1264,"line_start":49,"line_end":49,"column_start":11,"column_end":24,"is_primary":true,"text":[{"text":"    eval::eval_commands(match cmds {","highlight_start":11,"highlight_end":24}],"label":"not found in `eval`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0425]\u001b[0m\u001b[0m\u001b[1m: cannot find function `eval_commands` in module `eval`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/terminal.rs:49:11\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m49\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    eval::eval_commands(match cmds {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in `eval`\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/eval.rs","byte_start":16820,"byte_end":17333,"line_start":468,"line_end":472,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"      match rarg.variant {","highlight_start":7,"highlight_end":27},{"text":"        ASTVal::Num(i) => Ok(AST { variant: ASTVal::String(i.to_string()), location: loc }),","highlight_start":1,"highlight_end":93},{"text":"        ASTVal::String(sr) => Ok(AST { variant: ASTVal::Num(f32::from_str(sr.trim()).map_err(|_| error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following string was given:\\n\\r{}\", sr)))?), location: loc }),","highlight_start":1,"highlight_end":246},{"text":"        _ => Err(error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following value was given:\\n\\r{}\", rarg)))","highlight_start":1,"highlight_end":146},{"text":"      }","highlight_start":1,"highlight_end":8}],"label":"expected `()`, found enum `Result`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/eval.rs","byte_start":16619,"byte_end":37138,"line_start":464,"line_end":930,"column_start":3,"column_end":2,"is_primary":false,"text":[{"text":"  match name {","highlight_start":3,"highlight_end":15},{"text":"    \"num\" => {","highlight_start":1,"highlight_end":15},{"text":"      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":166},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::Num(i) => Ok(AST { variant: ASTVal::String(i.to_string()), location: loc }),","highlight_start":1,"highlight_end":93},{"text":"        ASTVal::String(sr) => Ok(AST { variant: ASTVal::Num(f32::from_str(sr.trim()).map_err(|_| error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following string was given:\\n\\r{}\", sr)))?), location: loc }),","highlight_start":1,"highlight_end":246},{"text":"        _ => Err(error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following value was given:\\n\\r{}\", rarg)))","highlight_start":1,"highlight_end":146},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    _ if is_arithmetic(name) => {","highlight_start":1,"highlight_end":34},{"text":"      if let (true, Some(ASTVal::Num(r))) = ( larg.is_none() && name == \"-\", &rarg.as_ref().map(|x| &x.variant)) {","highlight_start":1,"highlight_end":115},{"text":"        return Ok(AST { variant: ASTVal::Num(-r), location: loc });","highlight_start":1,"highlight_end":68},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      if let (true, Some(ASTVal::String(r))) = ( larg.is_none() && name == \"-\", &rarg.as_ref().map(|x| &x.variant)) {","highlight_start":1,"highlight_end":118},{"text":"        return Ok(AST { variant: ASTVal::Array(r.graphemes(true).map(|x| AST { variant: ASTVal::String(x.to_string()), location: loc }).collect()), location: loc });","highlight_start":1,"highlight_end":166},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      if let (true, None, Some(x)) = (name == \"*\", &larg, &rarg) {","highlight_start":1,"highlight_end":67},{"text":"        return Ok(AST { variant: ASTVal::Num(!is_truthy(&x) as u8 as f32), location: loc });","highlight_start":1,"highlight_end":93},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":165},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      if let (ASTVal::Num(l), ASTVal::Num(r)) = (&larg.variant, &rarg.variant) {","highlight_start":1,"highlight_end":81},{"text":"        Ok(AST { variant: ASTVal::Num(arithmetic(name, *l, *r)), location: loc })","highlight_start":1,"highlight_end":82},{"text":"      } else if let (true, ASTVal::String(s1), ASTVal::String(s2)) = (name == \"+\", &larg.variant, &rarg.variant) {","highlight_start":1,"highlight_end":115},{"text":"        Ok(AST { variant: ASTVal::String(s1.to_string() + s2.as_str()), location: loc })","highlight_start":1,"highlight_end":89},{"text":"      } else {","highlight_start":1,"highlight_end":15},{"text":"        Err(error(s, loc.col, loc.len, format!(\"Cannot perform arithmetic {0} on mistyped value.\", name), noteformat!(\"The left value was:\\n\\r{}\\n\\rAnd the right value was:\\n\\r{}\", larg, rarg)))","highlight_start":1,"highlight_end":195},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    \"cd\" => {","highlight_start":1,"highlight_end":14},{"text":"      if fail_extern {","highlight_start":1,"highlight_end":23},{"text":"        return Err(\"[cmd]\".to_string());","highlight_start":1,"highlight_end":41},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":166},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::String(st) => {","highlight_start":1,"highlight_end":32},{"text":"          let root = Path::new(&st);","highlight_start":1,"highlight_end":37},{"text":"          if let Err(e) = env::set_current_dir(&root) {","highlight_start":1,"highlight_end":56},{"text":"            Err(error(s, loc.col, loc.len, format!(\"Could not open directory — {}\", e), \"Try `ls` to list extant directories.\"))","highlight_start":1,"highlight_end":129},{"text":"          } else {","highlight_start":1,"highlight_end":19},{"text":"            Ok(AST { variant: ASTVal::Array(Vec::new()), location: loc })","highlight_start":1,"highlight_end":74},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        ASTVal::Array(vs) if vs.len() == 0 => {","highlight_start":1,"highlight_end":48},{"text":"          let root = Path::new(\"..\");","highlight_start":1,"highlight_end":38},{"text":"          if let Err(e) = env::set_current_dir(&root) {","highlight_start":1,"highlight_end":56},{"text":"            Err(error(s, loc.col, loc.len, format!(\"Could not open directory — {}\", e), \"This error occurred because a higher directory could not be opened.\"))","highlight_start":1,"highlight_end":160},{"text":"          } else {","highlight_start":1,"highlight_end":19},{"text":"            Ok(AST { variant: ASTVal::Array(Vec::new()), location: loc })","highlight_start":1,"highlight_end":74},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"        _ => Err(error(s, rarg.location.col, rarg.location.len, \"Expected string to indicate directory.\", noteformat!(\"The given value was:\\n\\r{}\", rarg)))","highlight_start":1,"highlight_end":156},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    \"exit\" => {","highlight_start":1,"highlight_end":16},{"text":"      if fail_extern {","highlight_start":1,"highlight_end":23},{"text":"        return Err(\"[cmd]\".to_string());","highlight_start":1,"highlight_end":41},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":166},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::Num(n) if n.fract() == 0.0 => std::process::exit(n.round() as i32),","highlight_start":1,"highlight_end":84},{"text":"        ASTVal::Array(vs) if vs.len() == 0 => std::process::exit(0),","highlight_start":1,"highlight_end":69},{"text":"        _ => Err(error(s, rarg.location.col, rarg.location.len, \"Require number for exit code.\", noteformat!(\"The given value was:\\n\\r{}\", rarg)))","highlight_start":1,"highlight_end":147},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    \"list\" => {","highlight_start":1,"highlight_end":16},{"text":"      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":166},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::String(s) => {","highlight_start":1,"highlight_end":31},{"text":"          let mut vs = s.split(\"\\n\").map(|e| AST { variant: ","highlight_start":1,"highlight_end":61},{"text":"              match e.split(\"\\t\").collect::<Vec<&str>>() {","highlight_start":1,"highlight_end":59},{"text":"                es if es.len() != 1 => ASTVal::Array(es.into_iter().map(|e| AST { variant: ASTVal::String(e.to_string()), location: loc }).collect()),","highlight_start":1,"highlight_end":151},{"text":"                mut es => ASTVal::String(es.remove(0).to_string())","highlight_start":1,"highlight_end":67},{"text":"              }, location: loc }).collect::<Vec<AST>>();","highlight_start":1,"highlight_end":57},{"text":"","highlight_start":1,"highlight_end":1},{"text":"          if vs.len() > 0 && match &vs[vs.len() - 1].variant { ASTVal::String(s) if s.len() == 0 => true, _ => false {","highlight_start":1,"highlight_end":119},{"text":"            vs.pop();","highlight_start":1,"highlight_end":22},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"          ","highlight_start":1,"highlight_end":11},{"text":"          Ok(AST { variant: match vs { vs if vs.len() != 1 => ASTVal::Array(vs), mut vs => vs.remove(0).variant }, location: loc })","highlight_start":1,"highlight_end":132},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        ASTVal::Array(vs) => Ok(AST { variant: ASTVal::String(vs.into_iter().map(|e| match e.variant {","highlight_start":1,"highlight_end":103},{"text":"          ASTVal::Array(vs2) => vs2.into_iter().map(|e| ast_stringify(e, s, loc)).collect::<Result<Vec<String>, String>>().map(|x| x.join(\"\\t\")),","highlight_start":1,"highlight_end":146},{"text":"          _ => ast_stringify(e, s, loc)","highlight_start":1,"highlight_end":40},{"text":"        }).collect::<Result<Vec<String>, String>>()?.join(\"\\n\")), location: loc }),","highlight_start":1,"highlight_end":84},{"text":"        _ => Err(error(s, loc.col, loc.len, \"Invalid argument to list.\", \"List either requires a string to translate to an array or an array to translate to a string.\"))","highlight_start":1,"highlight_end":170},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    x if x == CHARSET::LTack => {","highlight_start":1,"highlight_end":34},{"text":"      Ok(unoptionize(larg))","highlight_start":1,"highlight_end":28},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::RTack => {","highlight_start":1,"highlight_end":34},{"text":"      Ok(unoptionize(rarg))","highlight_start":1,"highlight_end":28},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::Take => {","highlight_start":1,"highlight_end":33},{"text":"      let (larg, rarg) = (match larg { Some(larg) => inpipe_to_ast(larg, s, &loc, StdoutCaptureType::Data)?, None => AST { variant: ASTVal::Num(1.0), location: loc } }, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":239},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let takenum = match larg.variant {","highlight_start":1,"highlight_end":41},{"text":"        ASTVal::Num(i) if i.fract() == 0.0 => Ok(i as i32),","highlight_start":1,"highlight_end":60},{"text":"        _ => Err(error(s, loc.col, loc.len, \"Invalid number to take.\", noteformat!(\"Expected integral count to take, instead found:\\n\\r{}\", larg)))","highlight_start":1,"highlight_end":148},{"text":"      }?;","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::Array(mut vs) => {","highlight_start":1,"highlight_end":35},{"text":"          if takenum.abs() as usize > vs.len() {","highlight_start":1,"highlight_end":49},{"text":"            return Err(error(s, loc.col, loc.len, \"Index out of bounds error.\", noteformat!(\"The given count to take is greater than the length of the array.  The count was:\\n\\r{}\\n\\rBut the array was:\\n\\r{}\", takenum, AST { variant: ASTVal::Array(vs), location: loc })));","highlight_start":1,"highlight_end":273},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"          if takenum >= 0 {","highlight_start":1,"highlight_end":28},{"text":"            let takenum = takenum as usize;","highlight_start":1,"highlight_end":44},{"text":"            Ok(AST { variant: ASTVal::Array(vs.drain(0..takenum).collect()), location: loc })","highlight_start":1,"highlight_end":94},{"text":"          } else {","highlight_start":1,"highlight_end":19},{"text":"            let takenum = -takenum as usize;","highlight_start":1,"highlight_end":45},{"text":"            let (s, e) = (vs.len() - takenum, vs.len());","highlight_start":1,"highlight_end":57},{"text":"            Ok(AST { variant: ASTVal::Array(vs.drain(s..e).collect()), location: loc })","highlight_start":1,"highlight_end":88},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        _ => Ok(rarg)","highlight_start":1,"highlight_end":22},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::Transpose => {","highlight_start":1,"highlight_end":38},{"text":"      let (larg, rarg) = (match larg { Some(larg) => Some(arrayifyast(inpipe_to_ast(larg, s, &loc, StdoutCaptureType::Data)?)), None => None }, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":214},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let ls = larg.map(|larg| match larg.variant {","highlight_start":1,"highlight_end":52},{"text":"        ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":33},{"text":"        _ => unreachable!()","highlight_start":1,"highlight_end":28},{"text":"      });","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let ls = match ls {","highlight_start":1,"highlight_end":26},{"text":"        Some(ls) => Some(ls.into_iter().map(|l| match l.variant {","highlight_start":1,"highlight_end":66},{"text":"        ASTVal::Num(x) if x >= 0.0 && x.fract() == 0.0 => Ok(x as u32 as usize),","highlight_start":1,"highlight_end":81},{"text":"        _ => Err(error(s, l.location.col, l.location.len, \"Invalid axis specifier.\", noteformat!(\"Expected an integral positive numeric argument, but instead found:\\n\\r{}\", l)))","highlight_start":1,"highlight_end":178},{"text":"      }).collect::<Result<Vec<usize>, String>>()?),","highlight_start":1,"highlight_end":52},{"text":"        None => None","highlight_start":1,"highlight_end":21},{"text":"      };","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      transpose(ls, rarg, s)","highlight_start":1,"highlight_end":29},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::MaxLast => {","highlight_start":1,"highlight_end":36},{"text":"      if larg.is_some() {","highlight_start":1,"highlight_end":26},{"text":"        let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":167},{"text":"        Ok(minmax(1, larg, rarg, loc))","highlight_start":1,"highlight_end":39},{"text":"      } else {","highlight_start":1,"highlight_end":15},{"text":"        let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":168},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        Ok(match arrayifyast(rarg).variant {","highlight_start":1,"highlight_end":45},{"text":"          ASTVal::Array(mut vs) if vs.len() > 0 => vs.pop().unwrap(),","highlight_start":1,"highlight_end":70},{"text":"          _ => AST { variant: ASTVal::Array(Vec::new()), location: loc }","highlight_start":1,"highlight_end":73},{"text":"        })","highlight_start":1,"highlight_end":11},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::MinFirst => {","highlight_start":1,"highlight_end":37},{"text":"      if larg.is_some() {","highlight_start":1,"highlight_end":26},{"text":"        let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":167},{"text":"        Ok(minmax(0, larg, rarg, loc))","highlight_start":1,"highlight_end":39},{"text":"      } else {","highlight_start":1,"highlight_end":15},{"text":"        let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":168},{"text":"          ","highlight_start":1,"highlight_end":11},{"text":"        Ok(match arrayifyast(rarg).variant {","highlight_start":1,"highlight_end":45},{"text":"          ASTVal::Array(mut vs) if vs.len() > 0 => vs.remove(0),","highlight_start":1,"highlight_end":65},{"text":"          _ => AST { variant: ASTVal::Array(Vec::new()), location: loc }","highlight_start":1,"highlight_end":73},{"text":"        })","highlight_start":1,"highlight_end":11},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::Concat => {","highlight_start":1,"highlight_end":35},{"text":"      let (larg, rarg) = (if larg.is_some() { Some(inpipe_to_ast(larg.unwrap(), s, &loc, StdoutCaptureType::Data)?) } else { None }, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":203},{"text":"      match larg {","highlight_start":1,"highlight_end":19},{"text":"        None => {","highlight_start":1,"highlight_end":18},{"text":"          Ok(AST { variant: ASTVal::Array(Vec::from([rarg])), location: loc })","highlight_start":1,"highlight_end":79},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        Some(larg) => {","highlight_start":1,"highlight_end":24},{"text":"          let mut larg = match arrayifyast(larg).variant {","highlight_start":1,"highlight_end":59},{"text":"            ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":37},{"text":"            _ => unreachable!()","highlight_start":1,"highlight_end":32},{"text":"          };","highlight_start":1,"highlight_end":13},{"text":"          let rarg = match arrayifyast(rarg).variant {","highlight_start":1,"highlight_end":55},{"text":"            ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":37},{"text":"            _ => unreachable!()","highlight_start":1,"highlight_end":32},{"text":"          };","highlight_start":1,"highlight_end":13},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"          larg.extend(rarg);","highlight_start":1,"highlight_end":29},{"text":"          Ok(AST { variant: ASTVal::Array(larg), location: loc })","highlight_start":1,"highlight_end":66},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::Greater => {","highlight_start":1,"highlight_end":36},{"text":"      if larg.is_some() {","highlight_start":1,"highlight_end":26},{"text":"        let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":167},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        Ok(AST { variant: ASTVal::Num((compare(&larg, &rarg) == std::cmp::Ordering::Less) as u32 as f32), location: loc })","highlight_start":1,"highlight_end":123},{"text":"      } else {","highlight_start":1,"highlight_end":15},{"text":"        let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, arrayifyast(inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?));","highlight_start":1,"highlight_end":181},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let vs = match rarg.variant {","highlight_start":1,"highlight_end":38},{"text":"          ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":35},{"text":"          _ => unreachable!()","highlight_start":1,"highlight_end":30},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        let mut is: Vec<usize> = (0..vs.len()).collect();","highlight_start":1,"highlight_end":58},{"text":"        is.sort_by(|a, b| compare(&vs[*a], &vs[*b]));","highlight_start":1,"highlight_end":54},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        Ok(AST { variant: ASTVal::Array(is.into_iter().map(|i| AST { variant: ASTVal::Num(i as f32), location: loc }).collect()), location: loc })","highlight_start":1,"highlight_end":147},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    x if x == CHARSET::Less => {","highlight_start":1,"highlight_end":33},{"text":"      if larg.is_some() {","highlight_start":1,"highlight_end":26},{"text":"        let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":167},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        Ok(AST { variant: ASTVal::Num((compare(&larg, &rarg) == std::cmp::Ordering::Greater) as u32 as f32), location: loc })","highlight_start":1,"highlight_end":126},{"text":"      } else {","highlight_start":1,"highlight_end":15},{"text":"        let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, arrayifyast(inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?));","highlight_start":1,"highlight_end":181},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let vs = match rarg.variant {","highlight_start":1,"highlight_end":38},{"text":"          ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":35},{"text":"          _ => unreachable!()","highlight_start":1,"highlight_end":30},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"        let mut is: Vec<usize> = (0..vs.len()).collect();","highlight_start":1,"highlight_end":58},{"text":"        is.sort_by(|a, b| compare(&vs[*a], &vs[*b]).reverse());","highlight_start":1,"highlight_end":64},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        Ok(AST { variant: ASTVal::Array(is.into_iter().map(|i| AST { variant: ASTVal::Num(i as f32), location: loc }).collect()), location: loc })","highlight_start":1,"highlight_end":147},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    x if x == CHARSET::Index => {","highlight_start":1,"highlight_end":34},{"text":"      let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":165},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::Array(ref vs) => {","highlight_start":1,"highlight_end":35},{"text":"          match larg.variant {","highlight_start":1,"highlight_end":31},{"text":"            ASTVal::Num(i) => if i >= 0.0 && i.fract() == 0.0 {","highlight_start":1,"highlight_end":64},{"text":"              let iusize = i as usize;","highlight_start":1,"highlight_end":39},{"text":"              if vs.len() > iusize {","highlight_start":1,"highlight_end":37},{"text":"                Ok(vs[iusize].clone())","highlight_start":1,"highlight_end":39},{"text":"              } else {","highlight_start":1,"highlight_end":23},{"text":"                Err(error(s, loc.col, loc.len, \"Index out of bounds.\", noteformat!(\"The index {} is out of bounds of:\\n\\r{}\", iusize, rarg)))","highlight_start":1,"highlight_end":142},{"text":"              }","highlight_start":1,"highlight_end":16},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"              Err(error(s, loc.col, loc.len, \"Index must be a nonnegative integer.\", noteformat!(\"The index supplied was: {}\", larg)))","highlight_start":1,"highlight_end":135},{"text":"            },","highlight_start":1,"highlight_end":15},{"text":"            _ => Err(error(s, loc.col, loc.len, \"Expected numeric index.\", noteformat!(\"The index supplied was:\\n\\r{}\", larg)))","highlight_start":1,"highlight_end":128},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        _ => Err(error(s, loc.col, loc.len, \"Expected array to index into.\", noteformat!(\"The value supplied was instead:\\n\\r{}\", rarg)))","highlight_start":1,"highlight_end":138},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    x if x == CHARSET::ShapeLength => {","highlight_start":1,"highlight_end":40},{"text":"      if larg.is_none() {","highlight_start":1,"highlight_end":26},{"text":"        let rarg = inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?;","highlight_start":1,"highlight_end":88},{"text":"        ","highlight_start":1,"highlight_end":9},{"text":"        Ok(AST { variant: ASTVal::Array(shapeof(&rarg).into_iter().map(|n| AST { variant: ASTVal::Num(n as u32 as i32 as f32), location: loc }).collect()), location: loc })","highlight_start":1,"highlight_end":173},{"text":"      } else {","highlight_start":1,"highlight_end":15},{"text":"        let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":167},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let vs = match arrayifyast(larg).variant {","highlight_start":1,"highlight_end":51},{"text":"          ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":35},{"text":"          _ => unreachable!()","highlight_start":1,"highlight_end":30},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut vs = vs.into_iter().map(|v| match v.variant {","highlight_start":1,"highlight_end":62},{"text":"          ASTVal::Num(i) if i.fract() == 0.0 => Ok(i as i32),","highlight_start":1,"highlight_end":62},{"text":"          _ => Err(\"bad num\".to_string())","highlight_start":1,"highlight_end":42},{"text":"        }).collect::<Result<Vec<i32>, String>>()?;","highlight_start":1,"highlight_end":51},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut rs = match arrayifyast(rarg).variant {","highlight_start":1,"highlight_end":55},{"text":"          ASTVal::Array(vs) => if vs.len() < 1 {","highlight_start":1,"highlight_end":49},{"text":"            Vec::from([AST { variant: ASTVal::Num(0.0), location: loc }])","highlight_start":1,"highlight_end":74},{"text":"          } else {","highlight_start":1,"highlight_end":19},{"text":"            vs ","highlight_start":1,"highlight_end":16},{"text":"          },","highlight_start":1,"highlight_end":13},{"text":"          _ => unreachable!()","highlight_start":1,"highlight_end":30},{"text":"        };","highlight_start":1,"highlight_end":11},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut vind = 0;","highlight_start":1,"highlight_end":26},{"text":"        Ok(reshape(&mut rs, &mut vind, &mut vs, 0, loc))","highlight_start":1,"highlight_end":57},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    x if x == CHARSET::Equal => {","highlight_start":1,"highlight_end":34},{"text":"      let (larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":165},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      Ok(AST { variant: ASTVal::Num(equality(&larg, &rarg) as u8 as f32), location: loc })","highlight_start":1,"highlight_end":91},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    x if x == CHARSET::Iota => {","highlight_start":1,"highlight_end":33},{"text":"      if larg.is_some() {","highlight_start":1,"highlight_end":26},{"text":"        let (larg, rarg) = (arrayifyast(inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?), arrayifyast(inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?));","highlight_start":1,"highlight_end":193},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        let mut res = Vec::from([Vec::new()]);","highlight_start":1,"highlight_end":47},{"text":"        if let (ASTVal::Array(ls), ASTVal::Array(mut rs)) = (larg.variant, rarg.variant) {","highlight_start":1,"highlight_end":91},{"text":"          for i in 0..rs.len() {","highlight_start":1,"highlight_end":33},{"text":"            if i >= ls.len() { break; }","highlight_start":1,"highlight_end":40},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let v = rs.remove(0);","highlight_start":1,"highlight_end":34},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            if is_truthy(&ls[i]) {","highlight_start":1,"highlight_end":35},{"text":"              res.last_mut().unwrap().push(v);","highlight_start":1,"highlight_end":47},{"text":"            } else {","highlight_start":1,"highlight_end":21},{"text":"              res.push(Vec::new());","highlight_start":1,"highlight_end":36},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        } else {","highlight_start":1,"highlight_end":17},{"text":"          unreachable!();","highlight_start":1,"highlight_end":26},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"","highlight_start":1,"highlight_end":1},{"text":"        return Ok(AST { variant: ASTVal::Array(res.into_iter().map(|x| AST { variant: ASTVal::Array(x), location: loc }).collect()), location: loc });","highlight_start":1,"highlight_end":151},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?);","highlight_start":1,"highlight_end":166},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let mut result = Vec::new();","highlight_start":1,"highlight_end":35},{"text":"      match rarg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::Num(i) => {","highlight_start":1,"highlight_end":28},{"text":"          let mut n = 0.0;","highlight_start":1,"highlight_end":27},{"text":"          while n < i {","highlight_start":1,"highlight_end":24},{"text":"            result.push(AST { variant: ASTVal::Num(n), location: loc });","highlight_start":1,"highlight_end":73},{"text":"            n += 1.0;","highlight_start":1,"highlight_end":22},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        _ => Err(error(s, rarg.location.col, rarg.location.len, \"Invalid argument to iota.\", noteformat!(\"Iota expects a numeric argument for sequence length, but instead found:\\n\\r{}\", rarg)))?","highlight_start":1,"highlight_end":195},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      Ok(AST { variant: ASTVal::Array(result), location: loc })","highlight_start":1,"highlight_end":64},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    \"collect\" => {","highlight_start":1,"highlight_end":19},{"text":"      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::All)?, inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::All)?);","highlight_start":1,"highlight_end":164},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      Ok(rarg)","highlight_start":1,"highlight_end":15},{"text":"    },","highlight_start":1,"highlight_end":7},{"text":"","highlight_start":1,"highlight_end":1},{"text":"    \"pipe\" => {","highlight_start":1,"highlight_end":16},{"text":"      let rarg = inpipe_to_ast(unoptionize(rarg), s, &loc, StdoutCaptureType::Data)?;","highlight_start":1,"highlight_end":86},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let v = rarg; // todo:","highlight_start":1,"highlight_end":29},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      let mut redir = Redirect { ","highlight_start":1,"highlight_end":34},{"text":"        stdout: ToRedirect::ToStdout,","highlight_start":1,"highlight_end":38},{"text":"        stderr: ToRedirect::ToStderr","highlight_start":1,"highlight_end":37},{"text":"      };","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let mut is_unchanged = (true, true);","highlight_start":1,"highlight_end":43},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let cannederr = Err(error(s, v.location.col, v.location.len, \"Invalid arguments to ].\", noteformat!(\"] expects pairs of symbols indicating rerouting.  It recieved:\\n\\r{}\", v)));","highlight_start":1,"highlight_end":184},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      let arrai = arrayifyast(v);","highlight_start":1,"highlight_end":34},{"text":"      match arrai.variant {","highlight_start":1,"highlight_end":28},{"text":"        ASTVal::Array(vs) => {","highlight_start":1,"highlight_end":31},{"text":"          let mut vs = vs;","highlight_start":1,"highlight_end":27},{"text":"          for i in 0..vs.len() {","highlight_start":1,"highlight_end":33},{"text":"            match &vs[i].variant {","highlight_start":1,"highlight_end":35},{"text":"              ASTVal::Symbol(x) if x == \"--swap\" => {","highlight_start":1,"highlight_end":54},{"text":"                vs.splice(i..i+1, ","highlight_start":1,"highlight_end":35},{"text":"                  [","highlight_start":1,"highlight_end":20},{"text":"                    AST { variant: ASTVal::Symbol(\"-o\".to_string()), location: vs[i].location },","highlight_start":1,"highlight_end":97},{"text":"                    AST { variant: ASTVal::Symbol(\"-e\".to_string()), location: vs[i].location },","highlight_start":1,"highlight_end":97},{"text":"                    AST { variant: ASTVal::Symbol(\"-e\".to_string()), location: vs[i].location },","highlight_start":1,"highlight_end":97},{"text":"                    AST { variant: ASTVal::Symbol(\"-o\".to_string()), location: vs[i].location }","highlight_start":1,"highlight_end":96},{"text":"                  ]","highlight_start":1,"highlight_end":20},{"text":"               );","highlight_start":1,"highlight_end":18},{"text":"              },","highlight_start":1,"highlight_end":17},{"text":"              ASTVal::Symbol(x) if x == \"--null\" => {","highlight_start":1,"highlight_end":54},{"text":"                vs.splice(i..i+1, ","highlight_start":1,"highlight_end":35},{"text":"                  [","highlight_start":1,"highlight_end":20},{"text":"                    AST { variant: ASTVal::Symbol(\"-o\".to_string()), location: vs[i].location },","highlight_start":1,"highlight_end":97},{"text":"                    AST { variant: ASTVal::Symbol(\"-n\".to_string()), location: vs[i].location },","highlight_start":1,"highlight_end":97},{"text":"                    AST { variant: ASTVal::Symbol(\"-e\".to_string()), location: vs[i].location },","highlight_start":1,"highlight_end":97},{"text":"                    AST { variant: ASTVal::Symbol(\"-n\".to_string()), location: vs[i].location }","highlight_start":1,"highlight_end":96},{"text":"                  ]","highlight_start":1,"highlight_end":20},{"text":"               );","highlight_start":1,"highlight_end":18},{"text":"              }","highlight_start":1,"highlight_end":16},{"text":"              _ => {}  ","highlight_start":1,"highlight_end":24},{"text":"            }","highlight_start":1,"highlight_end":14},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"          ","highlight_start":1,"highlight_end":11},{"text":"          if vs.len() % 2 != 0 {","highlight_start":1,"highlight_end":33},{"text":"            return cannederr;","highlight_start":1,"highlight_end":30},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"","highlight_start":1,"highlight_end":1},{"text":"          for pair in vs.chunks(2) {","highlight_start":1,"highlight_end":37},{"text":"            let lsym = match &pair[0].variant {","highlight_start":1,"highlight_end":48},{"text":"              ASTVal::Symbol(s) => s,","highlight_start":1,"highlight_end":38},{"text":"              _ => { return cannederr; }","highlight_start":1,"highlight_end":41},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"            let rsym = match &pair[1].variant {","highlight_start":1,"highlight_end":48},{"text":"              ASTVal::Symbol(s) => s,","highlight_start":1,"highlight_end":38},{"text":"              _ => { return cannederr; }","highlight_start":1,"highlight_end":41},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"","highlight_start":1,"highlight_end":1},{"text":"            let togo = match rsym.as_str() {","highlight_start":1,"highlight_end":45},{"text":"              \"-o\" => ToRedirect::ToStdout,","highlight_start":1,"highlight_end":44},{"text":"              \"-e\" => ToRedirect::ToStderr,","highlight_start":1,"highlight_end":44},{"text":"              \"-n\" => ToRedirect::ToNull,","highlight_start":1,"highlight_end":42},{"text":"              _ => { return cannederr; }","highlight_start":1,"highlight_end":41},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"            ","highlight_start":1,"highlight_end":13},{"text":"            match lsym.as_str() {","highlight_start":1,"highlight_end":34},{"text":"              \"-o\" => {","highlight_start":1,"highlight_end":24},{"text":"                if is_unchanged.0 || redir.stdout == ToRedirect::ToNull {","highlight_start":1,"highlight_end":74},{"text":"                  redir.stdout = togo;","highlight_start":1,"highlight_end":39},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                  if togo != ToRedirect::ToNull && togo != redir.stdout {","highlight_start":1,"highlight_end":74},{"text":"                    redir.stdout = ToRedirect::ToBoth;","highlight_start":1,"highlight_end":55},{"text":"                  }","highlight_start":1,"highlight_end":20},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                is_unchanged.0 = false;","highlight_start":1,"highlight_end":40},{"text":"              },","highlight_start":1,"highlight_end":17},{"text":"              \"-e\" => {","highlight_start":1,"highlight_end":24},{"text":"                if is_unchanged.1 || redir.stderr == ToRedirect::ToNull {","highlight_start":1,"highlight_end":74},{"text":"                  redir.stderr = togo;","highlight_start":1,"highlight_end":39},{"text":"                } else {","highlight_start":1,"highlight_end":25},{"text":"                  if togo != ToRedirect::ToNull && togo != redir.stderr {","highlight_start":1,"highlight_end":74},{"text":"                    redir.stderr = ToRedirect::ToBoth;","highlight_start":1,"highlight_end":55},{"text":"                  }","highlight_start":1,"highlight_end":20},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                is_unchanged.1 = false;","highlight_start":1,"highlight_end":40},{"text":"              }","highlight_start":1,"highlight_end":16},{"text":"              _ => { return cannederr; }","highlight_start":1,"highlight_end":41},{"text":"            };","highlight_start":1,"highlight_end":15},{"text":"          }","highlight_start":1,"highlight_end":12},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"        _ => unreachable!()","highlight_start":1,"highlight_end":28},{"text":"      };","highlight_start":1,"highlight_end":9},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let larg = eval_command(unoptionize(larg), s, env, fail_extern)?;","highlight_start":1,"highlight_end":72},{"text":"      match larg.variant {","highlight_start":1,"highlight_end":27},{"text":"        ASTVal::Command(c, ags, si, _r) => Ok(AST { variant: ASTVal::Command(c, ags, si, redir), location: larg.location }),","highlight_start":1,"highlight_end":125},{"text":"        _ => Ok(larg)","highlight_start":1,"highlight_end":22},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"    ","highlight_start":1,"highlight_end":5},{"text":"    comm => {","highlight_start":1,"highlight_end":14},{"text":"      if fail_extern {","highlight_start":1,"highlight_end":23},{"text":"        return Err(\"[cmd]\".to_string());","highlight_start":1,"highlight_end":41},{"text":"      }","highlight_start":1,"highlight_end":8},{"text":"","highlight_start":1,"highlight_end":1},{"text":"      let rr = unoptionize(rarg);","highlight_start":1,"highlight_end":34},{"text":"      ","highlight_start":1,"highlight_end":7},{"text":"      Ok(AST{ ","highlight_start":1,"highlight_end":15},{"text":"        variant: ASTVal::Command(","highlight_start":1,"highlight_end":34},{"text":"          comm.to_string(),","highlight_start":1,"highlight_end":28},{"text":"          match rr.variant {","highlight_start":1,"highlight_end":29},{"text":"            ASTVal::Array(vs) => vs,","highlight_start":1,"highlight_end":37},{"text":"            _ => Vec::from([rr])","highlight_start":1,"highlight_end":33},{"text":"          },","highlight_start":1,"highlight_end":13},{"text":"          Box::new(unoptionize(larg)),","highlight_start":1,"highlight_end":39},{"text":"          redr","highlight_start":1,"highlight_end":15},{"text":"        ),","highlight_start":1,"highlight_end":11},{"text":"        location: loc ","highlight_start":1,"highlight_end":23},{"text":"      })","highlight_start":1,"highlight_end":9},{"text":"    }","highlight_start":1,"highlight_end":6},{"text":"  }","highlight_start":1,"highlight_end":4},{"text":"}","highlight_start":1,"highlight_end":2}],"label":"expected this to be `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected unit type `()`\n        found enum `Result<AST, String>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"consider using a semicolon here","code":null,"level":"help","spans":[{"file_name":"src/eval.rs","byte_start":17333,"byte_end":17333,"line_start":472,"line_end":472,"column_start":8,"column_end":8,"is_primary":true,"text":[{"text":"      }","highlight_start":8,"highlight_end":8}],"label":null,"suggested_replacement":";","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"consider using a semicolon here","code":null,"level":"help","spans":[{"file_name":"src/eval.rs","byte_start":37138,"byte_end":37138,"line_start":930,"line_end":930,"column_start":2,"column_end":2,"is_primary":true,"text":[{"text":"}","highlight_start":2,"highlight_end":2}],"label":null,"suggested_replacement":";","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null},{"message":"you might have meant to return this value","code":null,"level":"help","spans":[{"file_name":"src/eval.rs","byte_start":16820,"byte_end":16820,"line_start":468,"line_end":468,"column_start":7,"column_end":7,"is_primary":true,"text":[{"text":"      match rarg.variant {","highlight_start":7,"highlight_end":7}],"label":null,"suggested_replacement":"return ","suggestion_applicability":"MaybeIncorrect","expansion":null},{"file_name":"src/eval.rs","byte_start":17333,"byte_end":17333,"line_start":472,"line_end":472,"column_start":8,"column_end":8,"is_primary":true,"text":[{"text":"      }","highlight_start":8,"highlight_end":8}],"label":null,"suggested_replacement":";","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/eval.rs:468:7\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m464\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m  match name {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m465\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"num\" => {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m466\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m      let (_larg, rarg) = (inpipe_to_ast(unoptionize(larg), s, &loc, StdoutCaptureType::Data)?, inpipe_to_ast(unoptionize(rarg), s, &loc,\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m467\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m468\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m      match rarg.variant {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ASTVal::Num(i) => Ok(AST { variant: ASTVal::String(i.to_string()), location: loc }),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        ASTVal::String(sr) => Ok(AST { variant: ASTVal::Num(f32::from_str(sr.trim()).map_err(|_| error(s, loc.col, loc.len, \"Invalid cand\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        _ => Err(error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following value was given:\\n\\r{}\",\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m      }\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_______^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected `()`, found enum `Result`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m929\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m  }\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m930\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mexpected this to be `()`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: expected unit type `\u001b[0m\u001b[0m\u001b[1m()\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m                    found enum `\u001b[0m\u001b[0m\u001b[1mResult<AST, String>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider using a semicolon here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m      }\u001b[0m\u001b[0m\u001b[38;5;10m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: consider using a semicolon here\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m930\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m}\u001b[0m\u001b[0m\u001b[38;5;10m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[38;5;10m+\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: you might have meant to return this value\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m468\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[38;5;10mreturn \u001b[0m\u001b[0mmatch rarg.variant {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m469\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        ASTVal::Num(i) => Ok(AST { variant: ASTVal::String(i.to_string()), location: loc }),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m470\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        ASTVal::String(sr) => Ok(AST { variant: ASTVal::Num(f32::from_str(sr.trim()).map_err(|_| error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following string was given:\\n\\r{}\", sr)))?), location: loc }),\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m471\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        _ => Err(error(s, loc.col, loc.len, \"Invalid candidate for numeric parsing.\", noteformat!(\"The following value was given:\\n\\r{}\", rarg)))\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m472\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m~ \u001b[0m\u001b[0m      }\u001b[0m\u001b[0m\u001b[38;5;10m;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\n"}
